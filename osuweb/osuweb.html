<html>
    <head>
        <title>Playarea</title>
        <style>
            body {
                background: black;
            }
            #playarea {
                width: 512px;
                height: 392px;
                border: 1px solid white;
                margin: auto;
                margin-top: 30px;
            }
            #objectContainer {
                position: relative;
                width: 100%;
                height: 100%;
            }
            .hitCircleContainer {
                position: absolute;
            }
            .hitCircleContainer canvas {
                position: absolute;
                top: 0px;
                left: 0px;
            }
            .sliderContainer canvas {
                position: absolute;
                top: 0px;
                left: 0px;
            }
            .sliderContainer {
                position: absolute;
            }
            @keyframes closeApproachCircle {
                from {transform: scale(3)}
                to {transform: scale(1)}
            }
        </style>
    </head>
    <body>
        <div id="playarea">
            <div id="objectContainer"></div>
        </div>
        
        <script src="js/osuweb.js"></script>
        <script>
            var ratio = 3 / 4;
            var width = Math.floor(window.innerWidth * 0.55 / 4) * 4;
            var height = width * ratio;
            var playareaDom = document.getElementById("playarea");
            playareaDom.style.width = width, playareaDom.style.height = height;
            var objectContainerDom = document.getElementById("objectContainer");
            
            var pixelRatio = width / osuweb.graphics.playAreaDimensions.x;
            var cs = 4;
            var csPixel = Math.round((109 - 9 * cs) / osuweb.graphics.playAreaDimensions.x * width);
            var halfCsPixel = csPixel / 2;
            var marginWidth = (osuweb.graphics.playAreaDimensions.x - osuweb.graphics.coordinateDimensions.x) / 2;
            var marginHeight = marginWidth * ratio;
            
            var ar = 0;
            var arMs = 1800 - 135 * ar;
            
            var PI2 = Math.PI * 2;
            var sliderTracePointDistance = 4;
            
            var derp = new Slider({sections: [
                {
                    sectionType: "bezier",
                    points: [
                        {x: 256, y: 117},
                        {x: 282, y: 186},
                        {x: 400, y: 200}
                    ]
                },
                {
                    sectionType: "bezier",
                    points: [
                        {x: 400, y: 200},
                        {x: 200, y: 400},
                        {x: 512, y: 10}
                    ]
                }
            ]});
            derp.append();
            
            var herp = new Circle({x: 256, y: 117});
            herp.append();
            
            function Circle(data) {
                this.type = "circle";
                this.time = data.time;
                this.newCombo = data.newCombo;
                this.x = data.x;
                this.y = data.y;
                
                this.append = function() {
                    this.containerDiv = document.createElement("div");
                    this.containerDiv.className = "hitCircleContainer";
                    this.containerDiv.style.left = ((this.x + marginWidth) * pixelRatio - halfCsPixel) + "px", this.containerDiv.style.top = ((this.y + marginHeight) * pixelRatio - halfCsPixel) + "px";
                    
                    this.containerDiv.style.display = "none";
                    this.containerDiv.style.opacity = 0;
                    this.containerDiv.style.transition = "opacity " + (arMs / 1000 / 3) + "s linear";
                    
                    var baseCanvas = document.createElement("canvas"); // Create local object canvas
                    baseCanvas.setAttribute("width", csPixel);
                    baseCanvas.setAttribute("height", csPixel);

                    var ctx = baseCanvas.getContext("2d");
                    drawCircle(ctx, 0, 0);
                    
                    this.approachCircleCanvas = document.createElement("canvas");
                    this.approachCircleCanvas.setAttribute("width", csPixel);
                    this.approachCircleCanvas.setAttribute("height", csPixel);
                    
                    var approachCtx = this.approachCircleCanvas.getContext("2d");
                    drawApproachCircle(approachCtx, 0, 0);

                    this.containerDiv.appendChild(baseCanvas);
                    this.containerDiv.appendChild(this.approachCircleCanvas);
                    objectContainerDom.appendChild(this.containerDiv);
                }
                
                this.show = function(offset) {
                    this.containerDiv.style.display = "block";
                    this.containerDiv.style.transition = "opacity " + (((arMs / 3) - offset) / 1000) + "s linear";
                    setTimeout(function() {
                        this.containerDiv.style.opacity = 1;
                        this.approachCircleCanvas.style.animation = "closeApproachCircle linear " + arMs / 1000 + "s";
                    }.bind(this));
                }
            }
            
            function Slider(data) {
                this.type = "slider";
                this.time = data.time;
                this.newCombo = data.newCombo;
                this.x = data.x, this.y = data.y;
                this.sections = data.sections;
                this.repeat = data.repeat;
                this.length = 500.863638593934;
                
                this.completion = 0; // experimental
                
                this.sliderPathPoints = [];
                
                var passedLength = 0,
                    lastPoint;
                
                function extendLength(pos, dist) { // Taking care of curve length exceeding pixelLength
                    var causeExit = false;
                    
                    if (dist) {
                        passedLength += dist;
                    } else if (lastPoint) {
                        passedLength += Math.hypot(lastPoint.x - pos.x, lastPoint.y - pos.y);
                    }
                    
                    if (passedLength > this.length) {
                        var angle = Math.atan2(pos.y - lastPoint.y, pos.x - lastPoint.x), dif = passedLength - this.length;
                        pos.x = lastPoint.x + dif * Math.cos(angle), pos.y = lastPoint.y + dif * Math.sin(angle);
                        
                        causeExit = true;
                    }
                    
                    lastPoint = pos;
                    pushPos.bind(this)(pos);
                    
                    if (causeExit) return true;
                }
                
                function pushPos(pos) { // Pushes endpoint to array
                    pos = {
                        x: pos.x * pixelRatio,
                        y: pos.y * pixelRatio
                    };
                    
                    this.sliderPathPoints.push(pos);
                    
                    this.minX = Math.min(this.minX, pos.x);
                    this.minY = Math.min(this.minY, pos.y);
                    this.maxX = Math.max(this.maxX, pos.x);
                    this.maxY = Math.max(this.maxY, pos.y);
                }
                
                (function() {
                    if (this.sections[0].sectionType == "circle") {
                        var points = this.sections[0].points;

                        var centerPos = osuweb.mathutil.circleCenterPos(points[0], points[1], points[2]);
                        var radius = Math.hypot(centerPos.x - points[0].x, centerPos.y - points[0].y);
                        var a1 = Math.atan2(points[0].y - centerPos.y, points[0].x - centerPos.x), // angle to start
                            a2 = Math.atan2(points[1].y - centerPos.y, points[1].x - centerPos.x), // angle to control point
                            a3 = Math.atan2(points[2].y - centerPos.y, points[2].x - centerPos.x); // angle to end

                        var incre = sliderTracePointDistance / radius, condition;

                        if (a1 < a2 && a2 < a3) { // Point order
                            condition = function(x) {return x < a3};
                        } else if ((a2 < a3 && a3 < a1) || (a3 < a1 && a1 < a2)) {
                            condition = function(x) {return x < a3 + PI2};
                        } else if (a3 < a1 && a1 < a2) {
                            condition = function(x) {return x < a3 + PI2};
                        } else if (a3 < a2 && a2 < a1) {
                            condition = function(x) {return x > a3};
                            incre *= -1;
                        } else {
                            condition = function(x) {return x > a3 - PI2};
                            incre *= -1;
                        }

                        this.minX = this.maxX = (centerPos.x + radius * Math.cos(a1)) * pixelRatio;
                        this.minY = this.maxY = (centerPos.y + radius * Math.sin(a1)) * pixelRatio;
                        
                        for (var angle = a1; condition(angle); angle += incre) {
                            if (extendLength.bind(this)({
                                x: centerPos.x + radius * Math.cos(angle),
                                y: centerPos.y + radius * Math.sin(angle)
                            })) {
                                return;
                            }
                        }
                    } else {
                        this.minX = this.maxX = this.sections[0].points[0].x * pixelRatio;
                        this.minY = this.maxY = this.sections[0].points[0].y * pixelRatio;
                        var p1;

                        for (var i = 0; i < this.sections.length; i++) {
                            var points = this.sections[i].points;

                            var leftT = 0, rightT = 0.01;
                            if (i == 0) {
                                p1 = osuweb.mathutil.coordsOnBezier(points, leftT);
                                extendLength.bind(this)(p1);
                            }
                            var p2 = osuweb.mathutil.coordsOnBezier(points, rightT);

                            while (leftT < 1) { // Binary segment approximation method
                                while (true) {
                                    var dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                                    if (dist < sliderTracePointDistance) {
                                        leftT += 0.01;
                                        rightT += 0.01;
                                        p2 = osuweb.mathutil.coordsOnBezier(points, rightT);
                                    } else {
                                        var p3, midT;

                                        while (true) {
                                            midT = (leftT + rightT) / 2;
                                            p3 = osuweb.mathutil.coordsOnBezier(points, midT);
                                            dist = Math.hypot(p3.x - p1.x, p3.y - p1.y);

                                            if (Math.abs(sliderTracePointDistance - dist) < 0.1) {
                                                break;
                                            }

                                            if (dist < sliderTracePointDistance) {
                                                leftT = midT;
                                            } else {
                                                rightT = midT;
                                            }
                                        }

                                        if (midT < 1) {
                                            if (extendLength.bind(this)(p3, dist)) {
                                                return;
                                            }
                                            p1 = p3;
                                        }

                                        leftT = midT;
                                        rightT = leftT + 0.01;
                                        p2 = osuweb.mathutil.coordsOnBezier(points, rightT);

                                        break;
                                    }
                                }
                            }
                        }
                    }
                }).bind(this)();
                
                if (passedLength < this.length) { // Fires when traced path is shorter than pixelLength
                    var endPos = this.sections[this.sections.length - 1].points[this.sections[this.sections.length - 1].points.length - 1];
                    var angle = Math.atan2(endPos.y - lastPoint.y, endPos.x - lastPoint.x);
                    var dif = this.length - passedLength;
                    
                    for (var dist = sliderTracePointDistance; dist < dif; dist += sliderTracePointDistance) {
                        pushPos.bind(this)({
                            x: lastPoint.x + dist * Math.cos(angle),
                            y: lastPoint.y + dist * Math.sin(angle)
                        });
                    }
                    
                    pushPos.bind(this)({
                        x: lastPoint.x + dif * Math.cos(angle),
                        y: lastPoint.y + dif * Math.sin(angle)
                    });
                }
                
                //////////
                
                this.append = function() {
                    var containerDiv = document.createElement("div");
                    containerDiv.className = "sliderContainer";
                    containerDiv.style.left = (this.minX - halfCsPixel) + marginWidth * pixelRatio + "px", containerDiv.style.top = (this.minY - halfCsPixel) + marginHeight * pixelRatio + "px";
                    containerDiv.style.display = "none";
                    
                    var sliderWidth = this.maxX - this.minX, sliderHeight = this.maxY - this.minY;
                    
                    var baseCanvas = document.createElement("canvas"); // Create local object canvas
                    baseCanvas.setAttribute("width", sliderWidth + csPixel);
                    baseCanvas.setAttribute("height", sliderHeight + csPixel);
                    
                    //canvas.style.display = "none";

                    var ctx = baseCanvas.getContext("2d");

                    ctx.beginPath();
                    ctx.moveTo(this.sliderPathPoints[0].x - this.minX + halfCsPixel, this.sliderPathPoints[0].y - this.minY + halfCsPixel);
                    for (var i = 1; i < this.sliderPathPoints.length; i++) {
                        ctx.lineTo(this.sliderPathPoints[i].x - this.minX + halfCsPixel, this.sliderPathPoints[i].y - this.minY + halfCsPixel);
                        
                        /*ctx.beginPath();
                        ctx.arc(this.sliderPathPoints[i].x - this.minX + halfCsPixel, this.sliderPathPoints[i].y - this.minY + halfCsPixel, 1, 0, PI2);
                        ctx.fillStyle = "white";
                        ctx.fill();*/
                    }
                    ctx.lineWidth = csPixel;
                    ctx.lineCap = "round";
                    ctx.lineJoin="round";
                    ctx.strokeStyle = "white";
                    ctx.stroke();

                    var sliderBodyRadius = halfCsPixel * 14.5 / 16;
                    ctx.lineCap = "round";
                    for (var i = sliderBodyRadius; i > 1; i -= 2) {
                        ctx.lineWidth = i * 2;
                        var completionRgb = Math.floor((1 - (i / sliderBodyRadius)) * 75);
                        ctx.strokeStyle = "rgb(" + completionRgb + ", " + completionRgb + ", "  + completionRgb + ")";
                        ctx.stroke();
                    }

                    drawCircle(ctx, this.sliderPathPoints[0].x - this.minX, this.sliderPathPoints[0].y - this.minY);

                    containerDiv.appendChild(baseCanvas);
                    
                    var overlay = document.createElement("canvas");
                    overlay.setAttribute("width", sliderWidth + csPixel);
                    overlay.setAttribute("height", sliderHeight + csPixel);
                    
                    var overlayCtx = overlay.getContext("2d");
                    
                    updateOverlay.bind(this)();
                    function updateOverlay() {
                        overlayCtx.clearRect(0, 0, sliderWidth + csPixel, sliderHeight + csPixel);
                        
                        var t = osuweb.mathutil.reflect(this.completion);
                        var actualIdx = t * (this.sliderPathPoints.length - 1);
                        var lowerIdx = Math.floor(actualIdx), upperIdx = Math.ceil(actualIdx);
                        var lowerPos = this.sliderPathPoints[lowerIdx];
                        var upperPos = this.sliderPathPoints[upperIdx];

                        var x = lowerPos.x * (1 - (actualIdx - lowerIdx)) + upperPos.x * (actualIdx - lowerIdx); // Linear interpolation between two points
                        var y = lowerPos.y * (1 - (actualIdx - lowerIdx)) + upperPos.y * (actualIdx - lowerIdx);
                        x = x - this.minX + halfCsPixel, y = y- this.minY + halfCsPixel;
                        
                        overlayCtx.beginPath();
                        overlayCtx.arc(x, y, sliderBodyRadius, 0, Math.PI * 2);
                        overlayCtx.fillStyle = "magenta";
                        overlayCtx.fill();
                        
                        this.completion += 0.0001;
                        requestAnimationFrame(updateOverlay.bind(this));
                    }
                    
                    //containerDiv.appendChild(overlay);
                    objectContainerDom.appendChild(containerDiv);
                }
            }
            
            function drawCircle(context, x, y) { // Draws circle used for Hit Circles, Slider Heads and Repeat Tails
                context.beginPath(); // Draw circle base (will become border)
                context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel, 0, PI2);
                context.fillStyle = "white";
                context.fill();
                
                var radialGradient = context.createRadialGradient(x + halfCsPixel, y + halfCsPixel, 0, x + halfCsPixel, y + halfCsPixel, halfCsPixel);
                radialGradient.addColorStop(0, "#5c5c5c");
                radialGradient.addColorStop(1, "black");
                
                context.beginPath(); // Draw circle body with radial gradient
                context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel * 14.5 / 16, 0, PI2);
                context.fillStyle = radialGradient;
                context.fill();
                
                var innerType = "dot";
                
                if (innerType == "number") {
                    context.font = "lighter 35px Arial";
                    context.textAlign = "center", context.textBaseline = "middle";
                    context.fillStyle = "white";
                    context.fillText("3", x + halfCsPixel, y + halfCsPixel);
                } else {
                    context.beginPath();
                    context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel * 0.25, 0, PI2);
                    context.fillStyle = "white";
                    context.fill();
                }
            }
            
            function drawApproachCircle(context, x, y) {
                context.beginPath(); // Draw circle base (will become border)
                context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel * ((14.5 / 16) + 1) / 2, 0, PI2);
                context.strokeStyle = "red";
                context.lineWidth = halfCsPixel * 1.5 / 16;
                context.stroke();
            }
        </script>
    </body>
</html>