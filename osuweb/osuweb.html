<html>
    <head>
        <title>Playarea</title>
        <style>
            body {
                background: black;
            }
            #playarea {
                width: 512px;
                height: 392px;
                border: 1px solid white;
                margin: auto;
                margin-top: 30px;
            }
            #objectContainer {
                position: relative;
                width: 100%;
                height: 100%;
            }
            .hitCircleContainer {
                position: absolute;
            }
            .sliderContainer canvas {
                position: absolute;
                top: 0px;
                left: 0px;
            }
            .sliderContainer {
                position: absolute;
            }
        </style>
    </head>
    <body>
        <div id="playarea">
            <div id="objectContainer"></div>
        </div>
        
        <script src="js/osuweb.js"></script>
        <script>
            var width = Math.floor(window.innerWidth * 0.5 / 4) * 4;
            width = 800;
            var height = width * 3 / 4;
            var playareaDom = document.getElementById("playarea");
            playareaDom.style.width = width, playareaDom.style.height = height;
            var objectContainerDom = document.getElementById("objectContainer");
            
            var pixelRatio = width / 640;
            var cs = 4;
            var csPixel = Math.round((109 - 9 * cs) / 640 * width);
            var halfCsPixel = csPixel / 2;
            var PI2 = Math.PI * 2;
            var sliderTracePointDistance = 5;
            
            function appendHitCircle(data) {
                var x = data.x,
                    y = data.y,
                    color = "#3c3cdd";
                
                var canvas = document.createElement("canvas"); // Create local object canvas
                canvas.setAttribute("width", csPixel);
                canvas.setAttribute("height", csPixel);
                canvas.className = "hitCircleCanvas";
                canvas.style.left = (x * pixelRatio - halfCsPixel) + "px", canvas.style.top = (y * pixelRatio - halfCsPixel) + "px";
                
                var ctx = canvas.getContext("2d");
                drawCircle(ctx, 0, 0);
                
                objectContainerDom.appendChild(canvas);
            }
            
            var derp = new Slider({sections: [
                {
                    sectionType: "bezier",
                    points: [
                        {x: 100, y: 100},
                        {x: 300, y: 300},
                        {x: 100, y: 390},
                        {x: 400, y: 200}
                    ]
                },
                {
                    sectionType: "bezier",
                    points: [
                        {x: 400, y: 200},
                        {x: 700, y: 310},
                        {x: 400, y: 420},
                    ]
                },
                {
                    sectionType: "linear",
                    points: [
                        {x: 400, y: 420},
                        {x: 210, y: 100}
                    ]
                }
            ]});
            derp.append();
            
            var herp = new Circle({x: 250, y: 400});
            herp.append();
            
            function Circle(data) {
                this.type = "circle";
                this.time = data.time;
                this.newCombo = data.newCombo;
                this.x = data.x;
                this.y = data.y;
                
                this.append = function() {
                    var containerDiv = document.createElement("div");
                    containerDiv.className = "hitCircleContainer";
                    containerDiv.style.left = (this.x * pixelRatio - halfCsPixel) + "px", containerDiv.style.top = (this.y * pixelRatio - halfCsPixel) + "px";
                    
                    var baseCanvas = document.createElement("canvas"); // Create local object canvas
                    baseCanvas.setAttribute("width", csPixel);
                    baseCanvas.setAttribute("height", csPixel);

                    var ctx = baseCanvas.getContext("2d");
                    drawCircle(ctx, 0, 0);

                    containerDiv.appendChild(baseCanvas);
                    objectContainerDom.appendChild(containerDiv);
                }
            }
            
            function Slider(data) {
                this.type = "slider";
                this.time = data.time;
                this.newCombo = data.newCombo;
                this.x = data.x, this.y = data.y;
                this.sections = data.sections;
                this.repeat = data.repeat;
                this.length = data.length;
                
                this.completion = 0; // experimental
                
                this.sliderPathPoints = [];
                
                function pushPos(pos) {
                    this.sliderPathPoints.push(pos);
                    
                    this.minX = Math.min(this.minX, pos.x);
                    this.minY = Math.min(this.minY, pos.y);
                    this.maxX = Math.max(this.maxX, pos.x);
                    this.maxY = Math.max(this.maxY, pos.y);
                }
                
                var initialPointTracing = [],
                    minX, minY, maxX, maxY;
                
                if (this.sections[0].sectionType == "circle") {
                    var points = this.sections[0].points;
                    
                    var centerPos = osuweb.mathutil.circleCenterPos(points[0], points[1], points[2]);
                    var radius = Math.hypot(centerPos.x - points[0].x, centerPos.y - points[0].y);
                    var a1 = Math.atan2(points[0].y - centerPos.y, points[0].x - centerPos.x), // angle to start
                        a2 = Math.atan2(points[1].y - centerPos.y, points[1].x - centerPos.x), // angle to control point
                        a3 = Math.atan2(points[2].y - centerPos.y, points[2].x - centerPos.x); // angle to end
                    
                    var incre = sliderTracePointDistance / radius, condition;
                    
                    if (a1 < a2 && a2 < a3) { // Point order
                        condition = function(x) {return x < a3};
                    } else if ((a2 < a3 && a3 < a1) || (a3 < a1 && a1 < a2)) {
                        condition = function(x) {return x < a3 + PI2};
                    } else if (a3 < a1 && a1 < a2) {
                        condition = function(x) {return x < a3 + PI2};
                    } else if (a3 < a2 && a2 < a1) {
                        condition = function(x) {return x > a3};
                        incre *= -1;
                    } else {
                        condition = function(x) {return x > a3 - PI2};
                        incre *= -1;
                    }
                    
                    this.minX = this.maxX = (centerPos.x + radius * Math.cos(a1)) * pixelRatio;
                    this.minY = this.maxY = (centerPos.y + radius * Math.sin(a1)) * pixelRatio;
                    
                    for (var angle = a1; condition(angle); angle += incre) {
                        pushPos.bind(this)({
                            x: (centerPos.x + radius * Math.cos(angle)) * pixelRatio,
                            y: (centerPos.y + radius * Math.sin(angle)) * pixelRatio
                        });
                    }
                    
                    var endPos = this.sections[this.sections.length - 1].points[this.sections[this.sections.length - 1].points.length - 1];
                    pushPos.bind(this)({
                        x: endPos.x * pixelRatio,
                        y: endPos.y * pixelRatio
                    }); // Pushes endpoint to array
                } else {
                    this.minX = this.maxX = this.sections[0].points[0].x * pixelRatio;
                    this.minY = this.maxY = this.sections[0].points[0].y * pixelRatio;
                    
                    for (var i = 0; i < this.sections.length; i++) {
                        var points = this.sections[i].points;
                        
                        for (var j = 0; j < points.length; j++) { // Maps points to local coordinate system
                            points[j].x *= pixelRatio;
                            points[j].y *= pixelRatio;
                        }
                        
                        var leftT = 0, rightT = 0.01;
                        var p1 = osuweb.mathutil.coordsOnBezier(points, leftT);
                        var p2 = osuweb.mathutil.coordsOnBezier(points, rightT);
                        
                        pushPos.bind(this)(p1);

                        while (leftT < 1) { // Binary segment approximation method
                            while (true) {
                                var dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                                if (dist < sliderTracePointDistance) {
                                    leftT += 0.01;
                                    rightT += 0.01;
                                    p2 = osuweb.mathutil.coordsOnBezier(points, rightT);
                                } else {
                                    var p3, midT;

                                    while (true) {
                                        midT = (leftT + rightT) / 2;
                                        p3 = osuweb.mathutil.coordsOnBezier(points, midT);
                                        dist = Math.hypot(p3.x - p1.x, p3.y - p1.y);

                                        if (Math.abs(sliderTracePointDistance - dist) < 0.1) {
                                            break;
                                        }

                                        if (dist < sliderTracePointDistance) {
                                            leftT = midT;
                                        } else {
                                            rightT = midT;
                                        }
                                    }

                                    if (midT < 1) {
                                        pushPos.bind(this)(p3);
                                        leftT = midT;
                                        rightT = leftT + 0.01;
                                        p1 = p3;
                                        p2 = osuweb.mathutil.coordsOnBezier(points, rightT);
                                    }
                                    
                                    break;
                                }
                            }
                        }
                    }
                    
                    var endPos = this.sections[this.sections.length - 1].points[this.sections[this.sections.length - 1].points.length - 1];
                    pushPos.bind(this)(endPos); // Pushes endpoint to array
                }
                
                console.log(this.sliderPathPoints.length);
                
                //////////
                
                this.append = function() {
                    var containerDiv = document.createElement("div");
                    containerDiv.className = "sliderContainer";
                    containerDiv.style.left = (this.minX - halfCsPixel) + "px", containerDiv.style.top = (this.minY - halfCsPixel) + "px";
                    
                    var sliderWidth = this.maxX - this.minX, sliderHeight = this.maxY - this.minY;
                    
                    var baseCanvas = document.createElement("canvas"); // Create local object canvas
                    baseCanvas.setAttribute("width", sliderWidth + csPixel);
                    baseCanvas.setAttribute("height", sliderHeight + csPixel);
                    
                    //canvas.style.display = "none";

                    var ctx = baseCanvas.getContext("2d");

                    ctx.beginPath();
                    ctx.moveTo(this.sliderPathPoints[0].x - this.minX + halfCsPixel, this.sliderPathPoints[0].y - this.minY + halfCsPixel);
                    for (var i = 1; i < this.sliderPathPoints.length; i++) {
                        ctx.lineTo(this.sliderPathPoints[i].x - this.minX + halfCsPixel, this.sliderPathPoints[i].y - this.minY + halfCsPixel);
                    }
                    ctx.lineWidth = csPixel;
                    ctx.lineCap = "round";
                    ctx.lineJoin="round";
                    ctx.strokeStyle = "white";
                    ctx.stroke();

                    var sliderBodyRadius = halfCsPixel * 14.5 / 16;
                    ctx.lineCap = "round";
                    for (var i = sliderBodyRadius; i > 1; i -= 2) {
                        ctx.lineWidth = i * 2;
                        var completionRgb = Math.floor((1 - (i / sliderBodyRadius)) * 75);
                        ctx.strokeStyle = "rgb(" + completionRgb + ", " + completionRgb + ", "  + completionRgb + ")";
                        ctx.stroke();
                    }

                    drawCircle(ctx, this.sliderPathPoints[0].x - this.minX, this.sliderPathPoints[0].y - this.minY);

                    containerDiv.appendChild(baseCanvas);
                    
                    var overlay = document.createElement("canvas");
                    overlay.setAttribute("width", sliderWidth + csPixel);
                    overlay.setAttribute("height", sliderHeight + csPixel);
                    
                    var overlayCtx = overlay.getContext("2d");
                    
                    updateOverlay.bind(this)();
                    function updateOverlay() {
                        overlayCtx.clearRect(0, 0, sliderWidth + csPixel, sliderHeight + csPixel);
                        
                        var t = osuweb.mathutil.reflect(this.completion);
                        var actualIdx = t * (this.sliderPathPoints.length - 1);
                        var lowerIdx = Math.floor(actualIdx), upperIdx = Math.ceil(actualIdx);
                        var lowerPos = this.sliderPathPoints[lowerIdx];
                        var upperPos = this.sliderPathPoints[upperIdx];

                        var x = lowerPos.x * (1 - (actualIdx - lowerIdx)) + upperPos.x * (actualIdx - lowerIdx); // Linear interpolation between two points
                        var y = lowerPos.y * (1 - (actualIdx - lowerIdx)) + upperPos.y * (actualIdx - lowerIdx);
                        x = x - this.minX + halfCsPixel, y = y- this.minY + halfCsPixel;
                        
                        overlayCtx.beginPath();
                        overlayCtx.arc(x, y, sliderBodyRadius, 0, Math.PI * 2);
                        overlayCtx.fillStyle = "magenta";
                        overlayCtx.fill();
                        
                        this.completion += 0.0025;
                        requestAnimationFrame(updateOverlay.bind(this));
                    }
                    
                    //containerDiv.appendChild(overlay);
                    objectContainerDom.appendChild(containerDiv);
                }
            }
            
            function drawCircle(context, x, y) { // Draws circle used for Hit Circles, Slider Heads and Repeat Tails
                context.beginPath(); // Draw circle base (will become border)
                context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel, 0, PI2);
                context.fillStyle = "white";
                context.fill();
                
                var radialGradient = context.createRadialGradient(x + halfCsPixel, y + halfCsPixel, 0, x + halfCsPixel, y + halfCsPixel, halfCsPixel);
                radialGradient.addColorStop(0, "#5c5c5c");
                radialGradient.addColorStop(1, "black");
                
                context.beginPath(); // Draw circle body with radial gradient
                context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel * 14.5 / 16, 0, PI2);
                context.fillStyle = radialGradient;
                context.fill();
                
                var innerType = "dot";
                
                if (innerType == "number") {
                    context.font = "lighter 35px Arial";
                    context.textAlign = "center", context.textBaseline = "middle";
                    context.fillStyle = "white";
                    context.fillText("3", x + halfCsPixel, y + halfCsPixel);
                } else {
                    context.beginPath();
                    context.arc(x + halfCsPixel, y + halfCsPixel, halfCsPixel * 0.25, 0, PI2);
                    context.fillStyle = "white";
                    context.fill();
                }
            }
        </script>
    </body>
</html>